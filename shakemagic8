import logging
import random
import os
from io import BytesIO
from PIL import Image, ImageDraw, ImageFont
from telegram import Update, InputFile
from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Enable logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.DEBUG
)
logger = logging.getLogger(__name__)

# Define the responses
responses = ["Yes", "No", "Maybe"]

# Function to overlay a vector image
def overlay_vector_image(base_image: Image, vector_image_path: str) -> Image:
    # Open the vector image and ensure it is in RGBA mode for transparency handling
    vector_img = Image.open(vector_image_path).convert("RGBA")
    # Get the dimensions of the base image
    x_center = (base_image.width - vector_img.width) // 2
    y_center = (base_image.height - vector_img.height) // 2
    # Paste the vector image onto the base image at the calculated position
    base_image.paste(vector_img, (x_center, y_center), vector_img)
    return base_image

# Function to generate the response image
def generate_response_image(user_image: BytesIO, vector_image_path: str) -> BytesIO:
    # Load the user image and convert it to RGBA for consistency
    user_img = Image.open(user_image).convert("RGBA")
    # Overlay the vector image
    user_img = overlay_vector_image(user_img, vector_image_path)
    # Create a draw object to add text
    draw = ImageDraw.Draw(user_img)
    # Choose a random response
    response = random.choice(responses)
    # Load a font with a large size for better visibility
    font = ImageFont.truetype("arial.ttf", 200)
    # Calculate text size and position
    text_width, text_height = draw.textsize(response, font=font)
    text_position = ((user_img.width - text_width) // 2, (user_img.height - text_height) // 2)
    # Add the response text to the image
    draw.text(text_position, response, font=font, fill="white")
    # Save the modified image to a BytesIO object
    output_image = BytesIO()
    user_img.save(output_image, format='PNG')
    output_image.seek(0)
    return output_image

# Command handler for /shake8ball
async def shake8ball(update: Update, context: CallbackContext) -> None:
    user = update.message.from_user
    logger.info("User %s initiated /shake8ball", user.first_name)
    await update.message.reply_text('Please send me a yes/no question followed by an image.')

# Message handler for images
async def handle_image(update: Update, context: CallbackContext) -> None:
    user = update.message.from_user
    logger.info("User %s sent an image", user.first_name)
    photo = await update.message.photo[-1].get_file()
    photo_file = BytesIO(await photo.download_as_bytearray())
    vector_image_path = "overlay.png"  # Ensure this path is correct
    response_image = generate_response_image(photo_file, vector_image_path)
    await update.message.reply_photo(photo=InputFile(response_image, filename="response.png"))

def main() -> None:
    token = os.getenv("TELEGRAM_BOT_TOKEN")
    if not token:
        logger.error("TELEGRAM_BOT_TOKEN environment variable not set")
        return
    application = Application.builder().token(token).build()
    application.add_handler(CommandHandler("shake8ball", shake8ball))
    application.add_handler(MessageHandler(filters.PHOTO & ~filters.COMMAND, handle_image))
    logger.info("Starting the bot")
    application.run_polling()

if __name__ == '__main__':
    logger.debug("Starting the bot script")
    main()
